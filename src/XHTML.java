package src;

import java.io.File;

import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.*;

import src.settings.*;
import src.typo.Formattings;
import src.utilities.StringTools;


/*
 *   Copyright (C) 2007-2010 Simon Eugster <granjow@users.sf.net>

 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.

 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.

 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 *
 * The main file of wiki2xhtml which parses the files.
 *
 * @author Simon Eugster
 * @deprecated
 */
public class XHTML {

	
	/**
	 * Insert title, body etc in the template and returns the result.
	 *
	 * @param reck says how and where to fill in the HTML code
	 * @param xhs XHTML Settings
	 * @return Complete (and perhaps correct) XHTML code. The content will have
	 *         been generated by the function wiki2xhtml.
	 */
	public static StringBuffer xhtmlToFile() throws IOException {
		StringBuffer out = new StringBuffer();

		if (xhs.local.contains(SettingsLocalE.script)) {
			out.append(xhs.local.get_(SettingsLocalE.script));
		}
		out.append(Container_Files.getInstance().cont.reck());

		int i, j;
		for (i = 0; (i = out.indexOf(">menu>", i)) < out.length() && i >= 0;) {
			/*
			 * Remove menu tags
			 */
			if ((j = out.indexOf("<menu<", i)) > 0) {
				if (!xhs.local.contains(SettingsLocalE.menu)) {
					// No menu: Delete everything between the two tags
					out.delete(i, j + "<menu<".length());
				} else {
					// Delete tags only
					out.delete(j, j + "<menu<".length());
					out.delete(i, i + ">menu>".length());
				}
			}
		}
		for (i = 0; (i = out.indexOf(">footer>", i)) < out.length() && i >= 0;) {
			/*
			 * Remove footer tags
			 */
			if ((j = out.indexOf("<footer<", i)) > 0) {
				if (xhs.global.footer == null) {
					// No footer: Delete everything between the two tags
					out.delete(i, j + "<footer<".length());
				} else {
					// Delete tags only
					out.delete(j, j + "<footer<".length());
					out.delete(i, i + ">footer>".length());
				}
			}
		}

		out = StringTools.replaceAll(out, Constants.TemplateTags.meta, xhs.local.metadata());
		out = StringTools.replaceAll(out, Constants.TemplateTags.title, xhs.local.title());
		out = replaceHead(out);
		out = StringTools.replaceAll(out, Constants.TemplateTags.textheader, xhs.local.get_(SettingsE.textHeader));
		out = StringTools.replaceAll(out, Constants.TemplateTags.menu, xhs.local.get_(SettingsLocalE.menu));
		out = StringTools.replaceAll(out, Constants.TemplateTags.footer, xhs.global.footer);
		out = StringTools.replaceAll(out, Constants.TemplateTags.h1, xhs.local.h1());
		out = StringTools.replaceAll(out, Constants.TemplateTags.homelink, xhs.homelink());
		out = StringTools.replaceAll(out, Constants.TemplateTags.content, xhs.local.content.toString());

		return out;
	}

	private static StringBuffer replaceHead(StringBuffer in) {

		StringBuffer n = new StringBuffer();
		String head;
		int last = 0;
		Matcher m = Constants.TemplateTags.regexHead.matcher(in.toString());
		while (m.find()) {
			n.append(in.substring(last, m.start()));
			head = xhs.local.head(m.group(1));
			if (head != null) n.append(head);
			last = m.end();
		}
		if (n.length() > 0) {
			n.append(in.substring(last));
			return n;
		}
		return in;
	}

	private static void p(int i) {
		UserInterface.setProgress(i);
	}

	/**
	 * Convert from Wiki to HTML
	 *
	 * @param ims
	 * @return converted HTML file (StringBuffer)
	 */
	public static StringBuffer wiki2xhtml() {
		StringBuffer out = new StringBuffer();
		Container_Settings sc = Container_Files.getInstance().sc;

		/*
		 * Clear the summary and the nowiki content, then parse the source
		 */
//		nowiki.clear();
//		out = xhs.local.content;

//		out = makeUnixLines(out);
//		out = XhtmlSettingsReader.getXhtml(out);
//		out = WikiNoWiki.removeNowikiContent(out);
//		out = src.templateHandler.TemplateManager.applyTemplates(out, null, null);
//		out = src.parserFunctions.Parser.parse(out);
//		out = WikiTables.makeTables(out);
//		out = WikiHeadings.makeHeadings(out);
//		out = WikiImages.makeImages(out);
//		out = WikiLinks.makeLinks(out, fc.currentFilename);
//		out = WikiLists.makeList(out);
//		out = WikiImages.makeGallery(out);
		p(76);
		out = makeHLines(out);
		p(79);
		out = Formattings.format0r(out, fc.currentFilename, Formattings.BOLD | Formattings.ITALIC | Formattings.MANY, true);
		p(86);
		out = Formattings.makeItalicType(out, true);
		p(92);
		StringTools.replaceAll(out, "\\\\ \n", "<br />\n");
		StringTools.replaceAll(out, "\\\\ ", "<br />\n");
		p(94);
//		out = WikiParagraphs.makeParagraphs(out);
//		p(96);
//		out = WikiNoWiki.insertNowikiContent(out);
//		p(98);
//		if (sc.removeLineBreaks)
//			out = StringTools.removeAllChars(out, "\n");
//		if (lineSepOS.equals("\r\n"))
//			out = makeWindowsLines(out);
//		p(99);

//		while (out.length() > 0 && out.charAt(0) == '\n')
//			out.deleteCharAt(0);

		p(100);

		return out;
	}

	public static StringBuffer makeHLines(StringBuffer in) {

		StringBuffer out = new StringBuffer();
		Matcher m = Pattern.compile("(?m)^----\\s*$").matcher(in.toString());

		short counter = 0;

		if (m.find()) {
			int last = 0, first;
			do {
				counter++;
				first = m.start();
				out.append(in.subSequence(last, first));
				last = m.end();
				out.append("<hr />" + lineSep);
			} while (m.find());
			out.append(in.subSequence(last, in.length()));
		} else
			out = in;

		Statistics.getInstance().counter.horizontalLines.increase(counter);

		return out;
	}
}
